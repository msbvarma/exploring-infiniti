{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Homepage","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#code-annotation-examples","title":"Code Annotation Examples","text":""},{"location":"#codeblocks","title":"Codeblocks","text":"<p>Some <code>code</code> goes here.</p>"},{"location":"#plain-codeblock","title":"Plain codeblock","text":"<p>A plain codeblock:</p> <pre><code>Some code here\ndef myfunction()\n// some comment\n</code></pre>"},{"location":"#code-for-a-specific-language","title":"Code for a specific language","text":"<p>Some more code with the <code>py</code> at the start:</p> <pre><code>import tensorflow as tf\ndef whatever()\n</code></pre>"},{"location":"#with-a-title","title":"With a title","text":"bubble_sort.py<pre><code>def bubble_sort(items):\nfor i in range(len(items)):\nfor j in range(len(items) - 1 - i):\nif items[j] &gt; items[j + 1]:\nitems[j], items[j + 1] = items[j + 1], items[j]\n</code></pre>"},{"location":"#with-line-numbers","title":"With line numbers","text":"<pre><code>def bubble_sort(items):\nfor i in range(len(items)):\nfor j in range(len(items) - 1 - i):\nif items[j] &gt; items[j + 1]:\nitems[j], items[j + 1] = items[j + 1], items[j]\n</code></pre>"},{"location":"#highlighting-lines","title":"Highlighting lines","text":"<pre><code>def bubble_sort(items):\nfor i in range(len(items)):\nfor j in range(len(items) - 1 - i):\nif items[j] &gt; items[j + 1]:\nitems[j], items[j + 1] = items[j + 1], items[j]\n</code></pre>"},{"location":"#icons-and-emojs","title":"Icons and Emojs","text":""},{"location":"about/","title":"About","text":""},{"location":"about/#bahubalendruni-m-s-b-varma","title":"Bahubalendruni M S B Varma","text":""},{"location":"LLD/LLD/","title":"LLD Cohort - 2023","text":"<p>Welcome Folks :)</p> <ul> <li>Chess</li> <li>Parking Lot</li> <li>Cab booking.</li> <li>Movie Ticket Booking</li> <li>enginEBogie.</li> </ul>"},{"location":"LLD/LLD/#what-is-low-level-design-their-formats-and-expectations-from-the-interviewers","title":"\ud83d\udc49 What is Low-Level Design, their formats, and expectations from the interviewers?","text":"<ul> <li>What it is?</li> <li> <p>Single Service</p> <ul> <li>Parking Lot     ParkingLot     Slot     Vehicle</li> </ul> </li> <li> <p>Formats</p> <ul> <li> <p>F2F - Face to face</p> <ul> <li>60 mins.</li> <li>You will get a problem</li> <li>You will come up with classes/properties of them.</li> <li>You will code few core areas of the classes.</li> </ul> </li> <li> <p>Machine Round</p> <ul> <li>Generally 2-2.5 hrs.</li> <li>You have code the full solution.</li> <li>Extensibility.</li> </ul> </li> </ul> </li> <li> <p>Interviewer Expectations</p> </li> <li> <p>Ask the interview what they are expecting.</p> </li> <li> <p>Goals</p> <ul> <li>Maintainability</li> <li>Extensibility</li> <li>Readable</li> <li>Testability - Unit testing.</li> </ul> </li> <li>Non Goals<ul> <li>Scalability - Number of users.</li> <li>Using external systems - Redis, db.<ul> <li>How can you switch between them easily.</li> </ul> </li> <li>Complex implementation - <ul> <li>Algo to be used.<ul> <li>Parking lot - Algorithm to be used for allocation<ul> <li>Iterate over a list - O(n)</li> <li>Random Function - O(1)</li> </ul> </li> </ul> </li> <li>List or map.</li> </ul> </li> <li>Concurrency.</li> </ul> </li> </ul>"},{"location":"LLD/LLD/#difference-between-principles-and-patterns","title":"\ud83d\udc49 Difference between principles and patterns","text":"<ul> <li>Principles - SOLID</li> <li>Patterns - Strategy, Composite, Factory, etc.</li> </ul>"},{"location":"LLD/LLD/#when-should-you-use-principles-and-when-should-you-use-patterns","title":"\ud83d\udc49 When should you use principles and when should you use patterns?","text":"<ul> <li> <p>When Principles?</p> <ul> <li>Guidance/Guidelines.</li> <li>Rules</li> <li>Analogy: We should be helpful beings.</li> <li>Useful for analysis.</li> </ul> </li> <li> <p>When Patterns?</p> <ul> <li>Something like templates.</li> <li>Defines way the objects need to behave.</li> <li>How you can achieve those rules.</li> </ul> </li> </ul>"},{"location":"LLD/LLD/#solid-principles","title":"\ud83d\udc49 SOLID Principles","text":"<p>S - SRP O - OCP L - LSP I - ISP D - DIP</p>"},{"location":"LLD/LLD/#single-responsibility","title":"\ud83d\udc68\u200d\ud83d\udcbb Single Responsibility.","text":"<ul> <li>Definition: <ul> <li>Single? One class should have single responsility.</li> <li>Single reason to change.</li> <li></li> </ul> </li> </ul> <p>Examples:</p> <ul> <li> <p>Parking Lot <pre><code>class SlotsManager {\nList&lt;Slot&gt; slots;\n}\nclass ParkingLot {\nList&lt;Slot&gt; slots;\nslots management\nvehicke management\ntickeeting management\n}\nclass TicketService {\n}\n===============\nclass SlotsManager {\nList&lt;CarSlot&gt; carSlots;\nList&lt;TruckSlot&gt; truckSlots;\n}\nclass TicketingService {\n}\nclass ParkingLot {\nSlotsManager slotsManager;\nTicketingServicetTicketingService;\n}\n</code></pre></p> </li> <li> <p>User Model Class <pre><code>class User {\nString id;\nString name;\nString address;\nString paymentMethods;\nString email;\n}\n</code></pre></p> </li> </ul> <pre><code>class Address {\nString city;\nString id;\nString state;\nString country;\n}\nclass PaymentMethod {\nString id;\nSttring type;\nString cardName;\nString walletName;\n}\nclass User {\nString id;\nString name;\nString country;\nList&lt;PaymentMethod&gt; paymentMethods;\nString email;\n}\n</code></pre>"},{"location":"LLD/LLD/#ocp-open-closed-principle","title":"\ud83d\udc68\u200d\ud83d\udcbb OCP - Open Closed Principle","text":"<ul> <li>? Open for extension and closed modification. - For any new case<ul> <li>class?</li> <li>interface?</li> <li>method? ? =-&gt; Any piece of code.</li> </ul> </li> <li>Less modifications for the existing classes.</li> <li> <p>Less number of test cases will be modified.</p> </li> <li> <p>Why:</p> <ul> <li>Less number of test cases will be modified.<ul> <li>More testing effort</li> </ul> </li> <li>We always create mistakes. We dont want to modify existing code.</li> <li>Not all the times, you have liberty to change it.</li> </ul> </li> <li> <p>Not allowed to change <pre><code>List&lt;String&gt; = new ArrayList&lt;&gt;();\nclass List {\nString[] strings;   size\ndelete\n}\nclass Integer {\nInteger[] integer;  size\ndelete\n}\n</code></pre></p> </li> </ul> <p><pre><code>// Key-Value -&gt; String\n// Eviction\nclass Cache {\n// Max 100 elements\nMap&lt;Object, Object&gt; elements;\nLRUEvictionPolicy lruEvictionPolicy;\nObject get(Object key) {\nreturn elements.get(key);\n}\nObject put(Object key, Object value) {\nif (elements.size() &gt; 100) {\nObject elementKey = lruEvictionPolicy.getElementToRemove();\nelements.remove(elementKey);\n}\nelements.put(key, value);\n}\n}\ninterface IEvictionPolicy {\nString getElementToRemove();\n}\nclass LRUEvictionPolicy implements IEvictionPolicy {\nString getElementToRemove() {\n}\n}\ninterface IStore {\nString store(String key, Stirng value);\nString get(String key);\n}\nclass LRUEvictionPolicy implements IEvictionPolicy {\nString getElementToRemove() {\n}\n}\nclass CacheItem {\n}\nclass StringItem extends CacheItem {\n}\nclass IntegerItem extends CacheItem {\n}\nclass Cache&lt;K, V&gt; {\nint maxSize;\n//Map&lt;K, V&gt; elements;\nIStore store;\nIEvictionPolicy lruEvictionPolicy;\nCache&lt;K, V&gt;(int maxSize) {\nthis.maxSize = maxSize;\n}\nCacheItem get(String key) {\nreturn elements.get(key);\n}\nV get(K key) {\nreturn elements.get(key);\n}\nV put(K key, V value) {\nif (elements.size() &gt; maxSize) {\nV elementKey = lruEvictionPolicy.getElementToRemove();\nelements.remove(elementKey);\n}\nelements.put(key, value);\n}\n}\n</code></pre> New problems in future. * Instead of string data type, it could be something else. * Cache size. * Eviction policy * What if I dont want to store the data in the map.</p>"},{"location":"LLD/LLD/#liskov-substitution-principle","title":"\ud83d\udc68\u200d\ud83d\udcbb Liskov Substitution principle.","text":"<ul> <li>A superclass should be usable wherever a subclass is needed.</li> <li>This principle is all about invariants.</li> </ul> <pre><code>class Order {\nprocessOrder(orderItem);\n}\nclass VideoBookingOrder extends Order {\nprocessOrder(orderItem) {\n// Validate\n// create a db entry\n}\n}\nclass EventOrder extends Order {\nprocessOrder(orderItem) {\n// Validate\n// create a db entry\n}   }\nclass CourseOrder extends Order {\nprocessOrder(orderItem) {\n// create a db entry\n}   }\nabstract class CacheItem {\nabstract equals();\nabstract hash();\n}\ninterface ICacheKey {\nequals();\nhash();\n}\ninterface IHashable {\n}\ninterface IEQualable {\n}\ninterface ICacheValue {\n}\ninterface ICacheItem {\nequals();\nhash();\n}\nclass StringItem extends CacheItem {\n}\nclass IntegerItem extends CacheItem {\n}\nclass UserItem extends CacheItem {\nequals();\nhash(){\n// Network\n// Not needed.\nreturn null;\n}\ndp {\n}\nprofileUrl {\n}\n}\nclass Cache {\nint maxSize;\n//Map&lt;K, V&gt; elements;\nMap&lt;CacheItem, CacheItem&gt; elements;\nLRUEvictionPolicy lruEvictionPolicy;\nCache(int maxSize) {\nthis.maxSize = maxSize;\n}\nCacheItem get(String key) {\nreturn elements.get(key);\n}\nCacheItem get(ICacheItem key) {\nreturn elements.get(key);\n}\nCacheItem put(CacheItem key, CacheItem value) {\nif (elements.size() &gt; maxSize) {\nCacheItem elementKey = lruEvictionPolicy.getElementToRemove();\nelements.remove(elementKey);\n}\nelements.put(key, value);\n}\n}\n</code></pre>"},{"location":"LLD/LLD/#interface-seggregation-principle","title":"\ud83d\udc68\u200d\ud83d\udcbb Interface Seggregation Principle","text":"<ul> <li>A single contract/interface(top level item) should not be overloaded.</li> </ul> <p>Cache <pre><code>abstract class CacheItem {\nabstract equals();\nabstract hash();\n}\ninterface ICacheKey {\nequals();\nhash();\n}\ninterface IHashable {\n}\ninterface IEQualable {\n}\ninterface ICacheValue {\n}\ninterface ICacheItem {\nequals();\nhash();\n}\nclass StringItem extends CacheItem {\n}\nclass IntegerItem extends CacheItem {\n}\nclass User extends CacheItem {\nequals();\nhash(){\n// Not needed.\nreturn null;\n}\n}\nclass Cache {\nint maxSize;\n//Map&lt;K, V&gt; elements;\nMap&lt;CacheItem, CacheItem&gt; elements;\nLRUEvictionPolicy lruEvictionPolicy;\nCache(int maxSize) {\nthis.maxSize = maxSize;\n}\nCacheItem get(String key) {\nreturn elements.get(key);\n}\nCacheItem get(CacheItem key) {\nreturn elements.get(key);\n}\nCacheItem put(CacheItem key, CacheItem value) {\nif (elements.size() &gt; maxSize) {\nCacheItem elementKey = lruEvictionPolicy.getElementToRemove();\nelements.remove(elementKey);\n}\nelements.put(key, value);\n}\n}\ninterface IAccount {\nwithdraw();\ndeposit();\nmature();\n}\ninterface IWithdrawalable {\n}\ninterface CreditCard implements IWithdrawalable, {\n}\ninterface Wallet implements IWithdrawalable, {\n}\ninterface SavingsAccount implements IWithdrawalable, {\n}\ninterface CurrentAccount implements IAccount {\n}\ninterface FixedDepositAccount implements IAccount {\n}\n</code></pre></p>"},{"location":"LLD/LLD/#dependency-inversion-principle","title":"\ud83d\udc68\u200d\ud83d\udcbb Dependency Inversion Principle","text":"<ul> <li>Class should depend on an interface rather than concrete classes.</li> <li>High and low level components depend on abstractions.</li> <li>High level modules shouldn't depend on low-level modules.</li> </ul> <pre><code>class Cache {\nint maxSize;\n//Map&lt;K, V&gt; elements;\nMap&lt;CacheItem, CacheItem&gt; elements;\nLRUEvictionPolicy lruEvictionPolicy;\nCache(int maxSize) {\nthis.maxSize = maxSize;\n}\nCacheItem get(String key) {\nreturn elements.get(key);\n}\nCacheItem get(CacheItem key) {\nreturn elements.get(key);\n}\nCacheItem put(CacheItem key, CacheItem value) {\nif (elements.size() &gt; maxSize) {\nCacheItem elementKey = lruEvictionPolicy.getElementToRemove();\nelements.remove(elementKey);\n}\nelements.put(key, value);\n}\n}\nclass LRUEvictionPolicy {\nList&lt;String&gt; list;\n}\n===\nISubscriber {\nprocessNewItem();\n}\nclass PubSubQueue {\nLogger logger;\nAnalytics analytics;\npublish(item) {\nlogger.publish(item);\nanalytics.publish(item);\n}\n}\nclass PubSubQueueV1 {\nList&lt;ISubscriber&gt; subscribers;\npublish(item) {\nfor (ISubscriber subscriber: subscribers) {\nsubscriber.processNewItem(item);\n}\n}\n}\n</code></pre>"},{"location":"interview/behavioural/beh/","title":"Behavioural Questions","text":""},{"location":"interview/behavioural/beh/#tell-me-about-yourself","title":"Tell me about yourself","text":""},{"location":"interview/java/java/","title":"Core Java Quick Dive","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"interview/java/java/#core-language","title":"Core Language","text":""},{"location":"interview/java/java/#datatypes","title":"DataTypes","text":"<ul> <li>Primitive<ul> <li>int whole number (4 bytes)</li> <li>long whole number (8 bytes)</li> <li>double decimal numbers (8 bytes)</li> <li>float decimal numbers (4)</li> <li>short whole numbe 2 bytes</li> <li>byte 1byte</li> <li>char 2 bytes</li> </ul> </li> <li>Non Primitive <ul> <li>String</li> <li>Array (Collection of similar data types)</li> <li>Class <ul> <li>Blue print for creating objects by providing initial values for state(variables) and implmentations of behaviour(methods)</li> </ul> </li> <li>Interface<ul> <li>An inteface is a collection of abstract(existing only as an idea, not as a physical thing) methods</li> </ul> </li> <li>Enum<ul> <li>To define set of named values</li> </ul> </li> <li>Record<ul> <li>To define a carrier of data (mostly variable data) </li> </ul> </li> </ul> </li> </ul> DataTypes.java<pre><code>public class DataTypes {\npublic static void main(String[] args) {\nint a = 10;\nlong b = 123343L;\ndouble d = 123.098;\nfloat f = 345.09f;\nString str = \"Hello world\";\nString[] names = {\"Bob\",\"john\"};\nint[] numbers = {1,2,3};\n}\n}\n/*By default it will be int or double, to make sure they take proper data types we mention L and f */\n</code></pre>"},{"location":"interview/java/java/#wrapper-classes","title":"Wrapper Classes","text":"<pre><code>`Integer, Long, Char, Float, Double`\n</code></pre> <p><pre><code>/* All Java Wrapper classes are **public and final**\n All wrapper classes are immutable i.e we can not change object state\n All are thred safe*/\npublic final class Long extends Number\nimplements Comparable&lt;Long&gt;, Constable, ConstantDesc {\n....\n}\n</code></pre> - Java5 introduced WrapperClasses to handle data in collections. In collections we cant create List, it should be List. <pre><code>   -- Constructor\nint number=10;\nInteger intWarpper = new Integer(number);\nInteger number = 123; //Autoboxing -An int automatically wrapping into Integer object\n</code></pre>"},{"location":"interview/java/java/#string","title":"String","text":""},{"location":"interview/java/java/#immutable","title":"Immutable","text":"<p>Effective Java by Joshua Bloch outlines several reasons to write immutable classes:</p> <ul> <li>Simplicity - each class is in one state only</li> <li>Thread Safe - because the state cannot be changed, no synchronization is required</li> <li>Writing in an immutable style can lead to more robust code. Imagine if Strings weren't immutable; Any getter methods that returned a String would require the implementation to create a defensive copy before the String was returned - otherwise a client may accidentally or maliciously break that state of the object. In general it is good practise to make an object immutable unless there are severe performance problems as a result. In such circumstances, mutable builder objects can be used to build immutable objects e.g. StringBuilder</li> <li>Hashmaps are a classic example. It's imperative that the key to a map be immutable. If the key is not immutable, and you change a value on the key such that hashCode() would result in a new value, the map is now broken (a key is now in the wrong location in the hash table.).</li> <li>Immutable strings and things Oracle Blog</li> <li> <p>In the beginning, there was Java 1.0, and within it there was the String class. The String class is final and has no mutator methods. Once a string has been constructed, it never changes. Methods that in some languages might change the string, such as toUpperCase(), in Java create a new String with the desired changes applied. A String is immutable, period, full stop (unless you bring in some native code using JNI to modify one).</p> </li> <li> <p>The need for immutable String objects was clearly understood by the team who created Java: If String objects could be modified, Java\u2019s entire security model would be broken. Here\u2019s a sketch of one potential attack. <pre><code>Good Thread: Open File xyz.\nInputStream Constructor; call security manager.\nSecurity manager - Read file xyz - Permission is OK.\nBad Thread wakes up at just this moment.\nChanges file name string from 'xyz' to '/etc/passwd'\nYields the CPU\nGood Thread\nInputStream Constructor: pass /etc/passwd to operating system open syscall\nBad Thread examines memory buffer for useful information to steal\n</code></pre></p> </li> <li>Furthermore, the immutability of String objects can lead to better multithreaded performance, as these objects do not require synchronization or checking when used in multithreaded code. The application, and the JVM, can take for granted that a String object\u2019s value will never change. Some <code>code</code> goes here.</li> </ul>"},{"location":"interview/java/java/#plain-codeblock","title":"Plain codeblock","text":"<p>A plain codeblock:</p> <pre><code>Some code here\ndef myfunction()\n// some comment\n</code></pre>"},{"location":"interview/java/java/#code-for-a-specific-language","title":"Code for a specific language","text":""},{"location":"interview/java/java/#highlighting-lines","title":"Highlighting lines","text":"bubble_sort.py<pre><code>def bubble_sort(items):\nfor i in range(len(items)):\nfor j in range(len(items) - 1 - i):\nif items[j] &gt; items[j + 1]:\nitems[j], items[j + 1] = items[j + 1], items[j]\n</code></pre>"},{"location":"interview/java/java/#icons-and-emojs","title":"Icons and Emojs","text":""}]}